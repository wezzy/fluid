----------------------------------------------------------------
						Appunti
----------------------------------------------------------------

1) Servizi condivisi:
	Autenticazione
		Zend_Auth
	Accesso al DB
		Zend_db
	ACL
		Zend_ACL
	Cache
		Zend_Cache
	Gestione delle pagine
		<Custom>
	Costruzione delle portlet
		 <Custom>
	Cosumo WS
		Zend_REST_Client
		Zend_Soap_Client
	Pubblicazione
		Zend_Rest_Server
		Zend_Soap_Server
	Layout
		<Custom>
	Template
		Smarty

	Per semplicità meglio mappare gli oggetti subclassandoli cosi' gli diamo un nome diverso da Zend_* e ci
	permette di modificarli senza invalidare tutto nelle prossime release

2) Community
	Come in liferay, contenitori dentro al quale valgono permessi differenti, ad esempio l'accesso è riservato solo a certi
	utenti

2) Pagine
	Gestione dell'albero di navigazione, per ciascuna pagina abbiamo:
		- titolo
		- url
		- padre

3) Anatomia di una portlet
	/portlest/index.php			// File principale
	/portlet/style.css			// Grafica contiene un commento all'inizio con i dati relativi alla portlet
	/portlet/template.smarty	// il layout grafico interno al box portlet

4) Portal lifecycle
	1 - Arriva la richiesta
	2 - Applico i filtri globali
	3 - Dispatcher riceve la richiesta e identifica la risorsa
	4 - Verifico i permessi per quella risorsa
		4.1 - se non li ho esco vado ad una pagina di errore
	5 - Applico i filtri di community
	6 - Inizializzo la community
	7 - Applico i filtri di pagina
	8 - Inializzo la pagina
	9 - Inizializzo tutte le portlet nella pagina
	10 - Filtri di uscita pagina
	11 - Filtri di uscita community
	12 - Filtri di uscita globali

	Ogni passaggio genera degli eventi before*() after*()

5) Portlet lifecycle
	1 setup()		// Viene resa disponibile per la comunicazione server side tra portlet
	2 start()		// Esegue il suo codice
	3 render()		// Esegue il template
	4 shutdown()	// Viene scaricata

6)	Url
		server/community/pagina/.../pagina/portlet/?parametri
		server/community/pagina/.../pagina/?parametri
	Se c'e' una portlet con il nome indicato il sistema la invoca e renderizza solamente lei. In questo caso non viene chiamato render()
	Portlet come tanti WS REST!


7) Comunicazione
	Server side:
		prima di invocare gli start() sulle portlet vengono tutte precaricate tramite setup() così che sia possibile comunicare tra una portlet e
		l'altra. L'obbiettivo è evitare di rifare su più portlet lo stesso lavoro. Una portlet ad esempio potrebbe non avere grafica ma recuperare
		dal database dei dati. Le alte portlet possono interrogare questa al posto di integrarsi la logica. Il sistema garantice che la portlet abbia
		ricevuto lo start() prima delle invocazioni (viene chiamato quando la portlet viene richeista dall'interno di un altra portlet)
	Client side:
		Con uno schema di url come quello descritto è possibile invocare direttamente una portlet. Verrà sviluppata una libreria JS per rendere la comunicazione
		tra portlet più immediata ma si tratta di una semplice richiesta GET con la specifica della portlet e gli eventuali parametri